<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1024</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Screen settings
width = 426;
height = 240;
postdraw_event = 8; // postdraw event - set to 8 to draw normally, 9 for special drawing of application_surface
vsync = true; // enabled by default.
window_scale = 2; // default window scale, 2x.
full_scale = min(display_get_width()/width, display_get_height()/height); // some drawing modes need this, no need to recalculate it every frame
center_delay = 3; // apparently two frames is not enough on Linux...
split_screen = false;
paused = false;
screenshot = -1; // for pausing
scanlines = false;
flashing_reduced = 1;
default_image_speed = 1;
intscalex = 0;
intscaley = 0;
interpolation = 0;
alarm[0] = center_delay;
view_enabled = true;
view_visible[0] = true;
view_wview[0] = width;
view_hview[0] = height;
view_wport[0] = width;
view_hport[0] = height;
if(objProgram.device_info &amp; DEVICE_TYPE_SMARTPHONE)
{
    // calculating what the definition would be if the game used the entire screen
    // first, the most common case: if the screen is of an aspect ratio larger than the game's native one
    var calculated_width = width;
    if(os_type == os_android)
    {
        if(display_get_orientation() == display_portrait
            || display_get_orientation() == display_portrait_flipped)
        {
            calculated_width = round(height * (display_get_height()/display_get_width()));
        }
        else
        {
            calculated_width = round(height * (display_get_width()/display_get_height()));
        }
        if(calculated_width mod 2)
        {
            calculated_width--;
        }
    }
    var maxgui_xscale, maxgui_yscale;
    if (calculated_width &gt;= width)
    {    
        // if the device's screen is wide enough, then this works
        maxgui_xscale = display_get_width()/calculated_width;
        maxgui_yscale = display_get_height()/height;
        var maxgui_xoffset = maxgui_xscale*(calculated_width - width)/2;
        
        display_set_gui_size(calculated_width, height);
        display_set_gui_maximise(maxgui_xscale, maxgui_yscale, maxgui_xoffset, 0);
        
        gui_width = calculated_width;
        gui_height = height;
    }
    else
    {
        // if the device's screen is not wide enough, then restart everything:
        // the width should be the fixed valuee, the height must be the recalculated instead
        var calculated_height = height;
        if(os_type == os_android)
        {
            if(display_get_orientation() == display_portrait
                || display_get_orientation() == display_portrait_flipped)
            {
                calculated_height = round(426 * (display_get_width()/display_get_height()));
            }
            else
            {
                calculated_height = round(426 * (display_get_height()/display_get_width()));
            }
            if(calculated_height mod 2)
            {
                calculated_height--;
            }
        }
        
        maxgui_xscale = display_get_width()/width;
        maxgui_yscale = display_get_height()/calculated_height;
        var maxgui_yoffset = maxgui_yscale*(calculated_height - height)/2;
        
        display_set_gui_size(width, calculated_height);
        display_set_gui_maximise(maxgui_xscale, maxgui_yscale, 0, maxgui_yoffset);    
        
        gui_width = width;
        gui_height = calculated_height;
        
    }
}
else
{
    display_set_gui_size(width, height);
    gui_width = width;
    gui_height = height;
}

surface_resize(application_surface, width, height); /* set up the app surf */

// A simple boolean that goes from between 0 and 1 every drawn frame
// Allows to remove some "mod" and "!boolean" calculations here and there
// while displaying flashing objects.
flashing_visible = false;

// A lot of flashing objects rely on objScreen.image_index mod 4
// This variable will replace the calls to that property, but
// only when the conditioned code is purely visual
frame_counter = 0;
/**
Load the appropriate video mode. See the apply_video_settings script for details
**/
video_mode = window_scale; // run in window_scale by default.
prev_video_mode = video_mode; // only used by Alt-Enter.
altenter_hold = false;
score_tally_mode = 0;
timer_mode = 0;
show_shield = 1;
/**
Set initial max scale
**/
event_user(3);
/**
0 - pre-1.1.2 format
1 - post-1.1.2 format, with new video mode.
2 - ??? reserved
**/
options_format_none = 0; // no format is present, fallback to pre-1.1.2
options_format = 1; // current, please increment this value on any changes.

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up
if sprite_exists(screenshot) { sprite_delete(screenshot); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Only apply interpolation setting
texture_set_interpolation(interpolation);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Center window after resize and apply interpolation
if (objProgram.device_info &amp; DEVICE_TYPE_COMPUTER) {
    if (window_scale != 0) {
        window_center();
    }
}
texture_set_interpolation(interpolation);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Unpause and handle Alt-Enter
if (not paused &amp;&amp; sprite_exists(screenshot)) {
    sprite_delete(screenshot);
    screenshot = -1;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// PostDraw event if integer scaling ON - draw app surface now
if (interpolation == 2) {
    texture_set_interpolation(false);
    draw_surface_ext(application_surface, intscalex, intscaley, window_scale, window_scale, 0, c_white, 1);
    texture_set_interpolation(true);
} else {
    draw_surface_ext(application_surface, intscalex, intscaley, window_scale, window_scale, 0, c_white, 1);
}   
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// PostDraw event if integer scaling OFF - no code here
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Apply blur - back (only relevant on Android)
if (objProgram.device_info &amp; DEVICE_OS_ANDROID) {
    interpolation = interpolation - 1;
    if (interpolation &lt; 0) {
        interpolation = 2;
    }
} else {
    interpolation = !interpolation;
}
alarm[1] = 1;
save_options();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Apply blur - forward (only relevant on Android)
if (objProgram.device_info &amp; DEVICE_OS_ANDROID) {
    interpolation = (interpolation + 1) mod 3;
} else {
    interpolation = !interpolation;
}
alarm[1] = 1;
apply_video_settings();
save_options();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Exclusively toggle fullscreen.

event_user(3);

if (video_mode &gt; 0) {
    /* save current window scale into a temp var and go fullscreen */
    prev_video_mode = video_mode;
    video_mode = 0;
}
else {
    /* restore previous scale */
    video_mode = prev_video_mode;
}

apply_video_settings();
save_options();
show_debug_message("video_mode = " + string(video_mode));

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Detect alt-enter or enter-alt presses.

// macOS special begin, this does nothing on any target that's not macOS!
if (objProgram.device_info &amp; DEVICE_OS_MACOS) {
    var _iswindowfs = window_get_fullscreen();
    var _isgamefs = video_mode == 0;
    // check if the window state does not match game's expected state.
    if (_iswindowfs &amp;&amp; !_isgamefs) {
        // window is now fullscreen, update video_mode accordingly
        prev_video_mode = video_mode;
        video_mode = 0; // fs
        window_scale = 0; // fs
        show_debug_message("osx: wnd -&gt; fs: prevscale=" + string(prev_video_mode));
        save_options();
    }
    else if (!_iswindowfs &amp;&amp; _isgamefs) {
        // fetch max_scale from display:
        event_user(3);
        // fun:
        var _scalebyX = clamp(window_get_width() div width, 1, max_scale);
        var _scalebyY = clamp(window_get_height() div height, 1, max_scale);
        // pick the minimum scale (so it fits)
        var _scaleguess = min(_scalebyX, _scalebyY);
        video_mode = _scaleguess;
        window_scale = _scaleguess;
        show_debug_message("osx: fs -&gt; wnd: scale=" + string(video_mode));
        save_options();
    }
    // do not execute the code below please, we can't do that.
    exit;
}
// macOS special end

// Since we can never trust GameMaker, let's handle Alt-Enter manually.
// oh and Alt-Enter can be pressed in various ways, Alt-Enter, Enter-Alt, weird!
// PS: This user event can technically be called from any object.
//     but since we are dealing with "quality" software
//     it is called in a with() from objInput.
var _altenter = keyboard_check(vk_alt) &amp;&amp; keyboard_check(vk_enter);

if (_altenter &amp;&amp; !altenter_hold) {
    altenter_hold = true;
    event_user(5);
}
else if (!_altenter &amp;&amp; altenter_hold) {
    altenter_hold = false;
}

// le GM moment.
if (altenter_hold) {
    keyboard_clear(vk_alt);
    keyboard_clear(vk_enter);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Detect maximum possible scale.

/* need to call that on every videomode change, since the
   display the window is displayed on can always change
   mind multiple displays, always */

/* always leave a margin e.g. for the taskbar (in pixels). */
var _dmargin = 50;
var _dw = display_get_width() - _dmargin;
var _dh = display_get_height() - _dmargin;

var _ms = 1;
while (width * _ms &lt; _dw &amp;&amp; height * _ms &lt; _dh) {
    ++_ms;
}

/* need to decrement by one, since the loop will quit only if the scale exceeds */
--_ms;

max_scale = _ms;
/* we're done here */

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///toggle vertical sync.
vsync = !vsync;
apply_video_settings();
save_options();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Scroll through screen modes - backwards
event_user(3);
--video_mode; if (video_mode &lt; 0) video_mode = max_scale;
apply_video_settings();
save_options();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Scroll through screen modes - forwards
event_user(3);
++video_mode; if (video_mode &gt; max_scale) video_mode = 0;
apply_video_settings();
save_options();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up
if sprite_exists(screenshot) { sprite_delete(screenshot); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup views
view_enabled = true;
image_index=0;
view_visible[0] = true;
view_visible[1] = split_screen;
if split_screen view_yport[1] = height * 0.5;
for (var i = 0; i &lt; 2; i += 1)
{
    view_wview[i] = width;
    view_hview[i] = height;
    view_wport[i] = width;
    view_hport[i] = height - (height * 0.5 * split_screen);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up
if sprite_exists(screenshot) { sprite_delete(screenshot); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// if integer scaling is active, it will be managed here
event_user(postdraw_event);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// manage flashing
flashing_visible = !flashing_visible;
frame_counter = (frame_counter + 1) mod 4;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Screenshot and scanlines
if sprite_exists(screenshot) &amp;&amp; !instance_exists(objSSHud)
{
    draw_enable_alphablend(false);
    draw_sprite_stretched_ext(screenshot, 0, view_xview[view_current], view_yview[view_current], width, height, c_white, 1);
    draw_enable_alphablend(true);
}
else if scanlines
{
    // draw the screenshot with a scanline shader?
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///scroll videomodes forward.
event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="112">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(debug_mode)
{
    show_debug_overlay(true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
